{"meta":{"title":"swimtobird的博客","subtitle":null,"description":"技术和日常点滴总结","author":"swimtobird","url":"http://swimtobird.github.io","root":"/"},"pages":[],"posts":[{"title":"Jenkins 如何持续构建","slug":"Jenkins 如何持续构建","date":"2020-10-20T11:12:19.000Z","updated":"2020-11-17T03:47:11.674Z","comments":true,"path":"post/Jenkins 如何持续构建.html","link":"","permalink":"http://swimtobird.github.io/post/Jenkins 如何持续构建.html","excerpt":"","text":"构建体系 创建任务 创建任务名称，并选择流水线，操作如下图所示 配置 添加环境配置参数 勾选Keep Jenkins Environment Variables和Keep Jenkins Build Variables，并添加参数内容，操作如下图所示 1234567891011# 在 Prepare an environment for the run 中的 Properties Content 填写一下参数# Jenkins拉取代码仓库的认证JENKINS_GIT_CODE_CREDENTIALSID=jenkins-pull-git# 代码仓库地址JENKINS_GIT_CODE_URL=# 代码仓库名称JENKINS_GIT_CODE_NAME=demo_mail# 项目名称JENKINS_PROJECT_NAME=demo_mail# 拉取代码仓库的分支(默认master)JENKINS_GIT_CODE_BRANCH=master 配置参数化构建过程 添加git、composer、phpcs、phpunit 配置webhook 12# 勾选Generic Webhook Trigger# 在token编写随机密匙 配置pipeline 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758pipeline &#123;agent &#123; node &#123; label &apos;master&apos; customWorkspace &quot;/usr/www/demo_mall&quot; &#125; &#125; parameters &#123; gitParameter branchFilter: &apos;origin/(.*)&apos;, defaultValue: &apos;master&apos;, name: &apos;branch_tag&apos;, type: &apos;PT_BRANCH&apos;// gitParameter name: &apos;branch_tag&apos;, description: &apos;请选择构建分支/标签...&apos;, type: &apos;PT_BRANCH_TAG&apos;, branchFilter: &apos;origin.*/(.*)&apos;, tagFilter: &apos;*&apos;, sortMode: &apos;DESCENDING_SMART&apos;, selectedValue: &apos;TOP&apos;, quickFilterEnabled: true, useRepository: &quot;.*$&#123;JENKINS_GIT_CODE_URL&#125;.git&quot; booleanParam(name: &apos;composer&apos;, defaultValue: false, description: &apos;是否构建&apos;) booleanParam(name: &apos;phpcs&apos;, defaultValue: false, description: &apos;是否语法检查&apos;) booleanParam(name: &apos;phpunit&apos;, defaultValue: false, description: &apos;是否单元测试&apos;) &#125; stages &#123; stage(&apos;拉取仓库代码&apos;) &#123; steps &#123; echo &apos;拉取仓库代码&apos; git branch: &quot;$&#123;branch_tag&#125;&quot;, url: &quot;$&#123;JENKINS_GIT_CODE_URL&#125;&quot; //sh &quot;git fetch origin &#123;branch_tag&#125;&quot; &#125; &#125; stage (&apos;编译代码&apos;)&#123; when &#123; expression &#123; return ( composer == &quot;true&quot; ) &#125; &#125; steps&#123; echo &quot;编译代码&quot; sh &quot;php72 /usr/sbin/composer install -vvv&quot; &#125; &#125; stage (&apos;语法检查&apos;)&#123; when &#123; expression &#123; return ( phpcs == &quot;true&quot; ) &#125; &#125; steps&#123; echo &quot;语法检查中....&quot; sh &quot;php72 /root/.composer/vendor/bin/phpcs --standard=psr1,psr2 app/&quot; &#125; &#125; stage (&apos;单元测试&apos;)&#123; when &#123; expression &#123; return ( phpunit == &quot;true&quot; ) &#125; &#125; steps&#123; echo &quot;单元测试中....&quot; sh &quot;php72 vendor/bin/phpunit tests/&quot; &#125; &#125; &#125;&#125; 码云配置webhook 将http://jenkins_ip/generic-webhook-trigger/invoke?token=xxxxx添加到码云webhook中 自此完成配置，开始体验jenkins构建吧","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"http://swimtobird.github.io/tags/jenkins/"},{"name":"持续构建","slug":"持续构建","permalink":"http://swimtobird.github.io/tags/持续构建/"}]},{"title":"cenos6.9下docker安装yapi","slug":"cenos6.9下docker安装yapi","date":"2020-10-20T07:16:26.000Z","updated":"2020-11-17T03:29:11.216Z","comments":true,"path":"post/cenos6.9下docker安装yapi.html","link":"","permalink":"http://swimtobird.github.io/post/cenos6.9下docker安装yapi.html","excerpt":"","text":"1、启动 MongoDB1.1拉取mongo镜像 1docker pull mongo:3.2 1.2 默认安装mongo 1docker run -d --name mongo-yapi mongo 1.3挂载宿主目录安装mongo 创建挂载目录 1mkdir -p /var/yapi/mongodata 运行mongo映射主机目录/var/yapi/mongodata 1docker run --restart always -v /var/yapi/mongodata:/data/db -d --name mongo-yapi mongo 2、获取 Yapi 镜像1docker pull registry.cn-hangzhou.aliyuncs.com/anoy/yapi 3、初始化 Yapi 数据库索引及管理员账号123456docker run -it --rm \\ --link mongo-yapi:mongo \\ --entrypoint npm \\ --workdir /api/vendors \\ registry.cn-hangzhou.aliyuncs.com/anoy/yapi \\ run install-server 4、启动 Yapi 服务1234567docker run -d \\ --name yapi \\ --link mongo-yapi:mongo \\ --workdir /api/vendors \\ -p 3000:3000 \\ registry.cn-hangzhou.aliyuncs.com/anoy/yapi \\ server/app.js 1server/app.js 使用 Yapi访问 http://localhost:3000 登录账号 **admin@admin.com，密码 ymfe.org**","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"yapi","slug":"yapi","permalink":"http://swimtobird.github.io/tags/yapi/"},{"name":"centos6.9","slug":"centos6-9","permalink":"http://swimtobird.github.io/tags/centos6-9/"}]},{"title":"Hyperf demo说明","slug":"Hyperf demo说明","date":"2020-10-18T11:12:19.000Z","updated":"2020-11-17T03:32:04.725Z","comments":true,"path":"post/Hyperf demo说明.html","link":"","permalink":"http://swimtobird.github.io/post/Hyperf demo说明.html","excerpt":"","text":"定义目录结构123456789├── app│ ├── Controller 控制器目录│ ├── Exception 异常以及异常处理器目录│ ├── Listener 监听器目录│ ├── Middleware 中间件目录│ ├── Model 数据模型目录│ ├── Request 请求验证器目录│ ├── Service 服务目录，业务逻辑处理，所有业务模块公用│ └── helpers.php 辅助方法 调用逻辑控制器 —–&gt;验证器—–&gt; 服务 —–&gt; 模型 编写注册 该涉及控制器、请求验证器、服务、模型、异常、异常处理器开发及其相关配置 需求保存新用户手机号与密码 开发过程数据库定义12345678 CREATE TABLE `users` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `phone` varchar(15) COLLATE utf8mb4_unicode_ci DEFAULT NULL, `password` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL, `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci; 生成迁移php bin/hyperf.php gen:migration create_users_table生成User控制器php bin/hyperf.php gen:controller UserController 生成User请求验证器 php bin/hyperf.php gen:request UserRequest 生成User模型 php bin/hyperf.php gen:model User 编写迁移脚步 12345678910111213 //migration/xxxx_xx_xx_xxxxxx_create_users_tablepublic function up(): void &#123; Schema::create('users', function (Blueprint $table) &#123; $table-&gt;bigIncrements('id'); $table-&gt;string('phone', 15)-&gt;nullable(); $table-&gt;string('password', 100)-&gt;nullable(false); $table-&gt;timestamp('created_at') -&gt;default(Db::raw('CURRENT_TIMESTAMP')); $table-&gt;timestamp('updated_at') -&gt;default(Db::raw('CURRENT_TIMESTAMP on update CURRENT_TIMESTAMP')); &#125;); &#125; 编写验证规则 1234567891011121314151617181920// app/Request/UserRequest.php public function rules(): array &#123; return [ 'phone' =&gt; [ 'required', 'regex:' . china_tel_regex(), ], 'password' =&gt; 'required|string', ]; &#125; public function messages(): array &#123; return [ 'phone.required' =&gt; '请填写手机号', 'phone.regex' =&gt; '填写合法手机号', 'password.required' =&gt; '请填写密码', ]; &#125; 创建App/Exception/BusinessException.php 123456//App/Exception/BusinessException.phpuse Hyperf\\Server\\Exception\\ServerException;class BusinessException extends ServerException&#123;&#125; 创建app/Exception/ValidationExceptionHandler.php 123456789101112131415161718192021222324252627282930313233343536//app/Exception/ValidationExceptionHandler.php&lt;?phpdeclare(strict_types=1);namespace App\\Exception\\Handler;use Hyperf\\ExceptionHandler\\ExceptionHandler;use Hyperf\\HttpMessage\\Stream\\SwooleStream;use Hyperf\\Utils\\Arr;use Hyperf\\Validation\\ValidationException;use Psr\\Http\\Message\\ResponseInterface;use Throwable;class ValidationExceptionHandler extends ExceptionHandler&#123; public function handle(Throwable $throwable, ResponseInterface $response) &#123; //阻止异常冒泡 $this-&gt;stopPropagation(); //返回自定义错误数据 $result = [ 'status' =&gt; 1, 'error' =&gt; current(Arr::dot($throwable-&gt;errors())), ]; return $response -&gt;withAddedHeader('content-type', 'application/json') -&gt;withBody(new SwooleStream(json_encode($result, JSON_UNESCAPED_UNICODE))); &#125; public function isValid(Throwable $throwable): bool &#123; return $throwable instanceof ValidationException; &#125;&#125; 创建app/Exception/BusinessExceptionHandler.php 1234567891011121314151617181920212223242526272829303132333435//app/Exception/BusinessExceptionHandler.php&lt;?phpdeclare(strict_types=1);namespace App\\Exception\\Handler;use App\\Exception\\BusinessException;use Hyperf\\ExceptionHandler\\ExceptionHandler;use Hyperf\\HttpMessage\\Stream\\SwooleStream;use Psr\\Http\\Message\\ResponseInterface;use Throwable;class BusinessExceptionHandler extends ExceptionHandler&#123; public function handle(Throwable $throwable, ResponseInterface $response) &#123; //阻止异常冒泡 $this-&gt;stopPropagation(); //返回自定义错误数据 $result = [ 'status' =&gt; 1, 'error' =&gt; $throwable-&gt;getMessage(), ]; return $response -&gt;withAddedHeader('content-type', 'application/json') -&gt;withBody(new SwooleStream(json_encode($result, JSON_UNESCAPED_UNICODE))); &#125; public function isValid(Throwable $throwable): bool &#123; return $throwable instanceof BusinessException; &#125;&#125; 注册异常处理器 目前仅支持配置文件的形式注册 异常处理器(ExceptionHandler)，配置文件位于 config/autoload/exceptions.php，将您的自定义异常处理器配置在对应的 server 下即可： 123456789101112 // config/autoload/exceptions.php return [ 'handler' =&gt; [ 'http' =&gt; [ /** * ...... */ App\\Exception\\Handler\\ValidationExceptionHandler::class, App\\Exception\\Handler\\BusinessExceptionHandler::class ], ],]; 创建 app/Service/UserService.php，编写注册方法 12345678910111213141516171819 // app/Service/UserService.phppublic function register(array $data) &#123; $exists = User::query()-&gt;where('phone', Arr::get($data, 'phone'))-&gt;exists(); if ($exists) &#123; throw new BusinessException('手机号已被注册'); &#125; $data = Arr::set($data, 'password', md5($data['password'])); $user = new User(); $user-&gt;phone = Arr::get($data, 'phone'); $user-&gt;password = Arr::get($data, 'password'); $user-&gt;save(); return $user; &#125; 编写控制器调用处理方法 12345678910//app/Controller/UserController.php public function store(UserRequest $request) &#123; //返回通过检验的数组 $userData = $request-&gt;validated(); $this-&gt;userService-&gt;register($userData); return success(); &#125; 配置路由 12//config/route.phpRouter::addRoute('POST', '/user', 'App\\Controller\\UserController@store'); 编写解密中间件 该模块涉及中间件开发及配置 需求在中间件中统一处理客户端加密的请求参数，解密后注入Request中 开发过程生成解密中间件php bin/hyperf.php gen:middleware DecryptMiddleware 在app/helpers.php添加解密方法 12345678910111213141516if (! function_exists('encrypt')) &#123; /** * @param $data * @return string */ function encrypt($data) &#123; $data = openssl_encrypt( json_encode($data), 'aes-128-ecb', env('AES_PRIVATE_KEY'), OPENSSL_RAW_DATA ); return base64_encode($data); &#125;&#125; 编辑解密中间件方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//app/Middleware/DecryptMiddleware.php&lt;?phpdeclare(strict_types=1);namespace App\\Middleware;use Hyperf\\HttpServer\\Contract\\RequestInterface;use Hyperf\\HttpServer\\Response;use Hyperf\\Utils\\Context;use Psr\\Container\\ContainerInterface;use Psr\\Http\\Message\\ResponseInterface;use Psr\\Http\\Message\\ServerRequestInterface;use Psr\\Http\\Server\\MiddlewareInterface;use Psr\\Http\\Server\\RequestHandlerInterface;class DecryptMiddleware implements MiddlewareInterface&#123; /** * @var ContainerInterface */ protected $container; /** * @var Response */ protected $response; /** * @var RequestInterface */ protected $request; public function __construct(ContainerInterface $container, RequestInterface $request) &#123; $this-&gt;container = $container; $this-&gt;request = $request; &#125; public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface &#123; $requestData = $this-&gt;request-&gt;input('requestData'); if ($requestData) &#123; $requestData = decrypt($requestData); if ($requestData) &#123; $parms = array_merge($this-&gt;request-&gt;all(), $requestData); $request = $request-&gt;withQueryParams($parms); /* * 由于Hyperf\\HttpServer\\Request的getInputData是放协程中并且是自命名，需要指定更新改变对象才能传递上下文 */ Context::override('http.request.parsedData', function () use ($request) &#123; if (is_array($request-&gt;getParsedBody())) &#123; $data = $request-&gt;getParsedBody(); &#125; else &#123; $data = []; &#125; return array_merge($data, $request-&gt;getQueryParams()); &#125;); $request = Context::set(ServerRequestInterface::class, $request); &#125; &#125; return $handler-&gt;handle($request); &#125;&#125; 配置中间件 123456789//config/autoload/middleware.phpreturn [ 'http' =&gt; [ /** * ...... */ App\\Middleware\\DecryptMiddleware::class, ],]; 编写登录 该涉及控制器、请求验证器、服务、模型、缓存、异常、异常处理器开发及其相关配置 需求通过手机号与密码登录，返回登录成功凭证 开发过程数据库定义 12345678910CREATE TABLE `user_token` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `user_id` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL, `access_token` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL, `refresh_token` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL, `effective_time` int(10) unsigned NOT NULL DEFAULT &apos;604800&apos; COMMENT &apos;有限时长(单位秒)&apos;, `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci; 编写模型 12345678910111213141516171819//app/Model/UserTokenconst EFFECTIVE_TIME = 60 * 60 * 24 * 14; public static function createToken($user_id) &#123; $access_token = md5($user_id . time() . random_bytes(2)); $refresh_token = md5($user_id . time() . random_bytes(2)); $data = [ 'user_id' =&gt; $user_id, 'access_token' =&gt; $access_token, 'refresh_token' =&gt; $refresh_token, 'effective_time' =&gt; self::EFFECTIVE_TIME, ]; self::insert($data); return $data; &#125; 编写登录方法 1234567891011121314151617181920212223242526 // app/Service/UserService.phppublic function login(array $data) &#123; $user = User::getFirstByWhere(['phone' =&gt; Arr::get($data, 'phone')]); if (! $user) &#123; throw new BusinessException('用户不存在'); &#125; $hash = password_hash(md5(Arr::get($data, 'password')), PASSWORD_DEFAULT); if (! password_verify($user-&gt;password, $hash)) &#123; throw new BusinessException('密码错误'); &#125; $result = UserToken::createToken($user-&gt;id); $result = Arr::except($result, 'user_id'); cache()-&gt;set( 'token:' . Arr::get($result, 'access_token'), $user-&gt;id, Arr::get($result, 'effective_time') ); return $result; &#125; 编写控制器调用处理方法 123456789//app/Controller/UserController.phppublic function login(UserRequest $request) &#123; $userData = $request-&gt;validated(); $result = $this-&gt;userService-&gt;login($userData); return success($result); &#125; 配置路由 12//config/route.phpRouter::addRoute('POST', '/user/token', 'App\\Controller\\UserController@login');","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"php","slug":"php","permalink":"http://swimtobird.github.io/tags/php/"},{"name":"hyperf","slug":"hyperf","permalink":"http://swimtobird.github.io/tags/hyperf/"},{"name":"swoole","slug":"swoole","permalink":"http://swimtobird.github.io/tags/swoole/"}]},{"title":"Hyperf安装","slug":"Hyperf开发","date":"2020-10-16T11:12:19.000Z","updated":"2020-11-17T03:32:08.891Z","comments":true,"path":"post/Hyperf开发.html","link":"","permalink":"http://swimtobird.github.io/post/Hyperf开发.html","excerpt":"","text":"安装swoole[若安装请跳过]没有安装的，可以按照swoole官方安装说明指示步骤安装即可 配置PHP先定位php.ini位置 12345[root@iZwz9dkdcnxsz2ul6p6n7iZ ~]# php --iniConfiguration File (php.ini) Path: /usr/local/php/libLoaded Configuration File: /usr/local/php/lib/php.iniScan for additional .ini files in: (none)Additional .ini files parsed: (none) 然后在php.ini添加swoole.use_shortname = off 123[root@iZwz9dkdcnxsz2ul6p6n7iZ ~]cat &gt; /usr/local/php/lib/php.ini &lt;&lt; \\EOFswoole.use_shortname = offEOF 创建Hyperf项目123456# 通过脚手架安装composer create-project hyperf/hyperf-skeleton -vvv# 进入安装好的 Hyperf 项目目录cd hyperf-skeleton# 启动 Hyperfphp bin/hyperf.php start 至此，安装完成，开始愉快编码了 优雅调试首先安装 Whoops 1composer require --dev filp/whoops 然后配置 Whoops 专用异常处理器。 12345678// config/autoload/exceptions.phpreturn [ 'handler' =&gt; [ 'http' =&gt; [ \\Hyperf\\ExceptionHandler\\Handler\\WhoopsExceptionHandler::class, ], ],]; 修改APP异常处理器处理，添加环境判断 12345678910// app/Exception/Handler/AppExceptionHandler public function isValid(Throwable $throwable): bool &#123; //return true; /** * 当环境是生产环境时候，该处理再启动 */ return env('APP_ENV') === 'prod'; &#125; 最终效果： 热更新 热更新，顾名思义就是文件被修改后立马重启，不需要重新执行命令，提高开发效率必备 请勿于生产环境使用，切记！切记！切记！重要事情说三次 首先安装 Watcher 1composer require hyperf/watcher --dev 然后如果是Mac系统 1brew install fswatchCopy to clipboardErrorCopied 如果是其他unix、linux系统 123456wget https://github.com/emcrisostomo/fswatch/releases/download/1.14.0/fswatch-1.14.0.tar.gz \\&amp;&amp; tar -xf fswatch-1.14.0.tar.gz \\&amp;&amp; cd fswatch-1.14.0/ \\&amp;&amp; ./configure \\&amp;&amp; make \\&amp;&amp; make install 最后将启动命令运行起来 1php bin/hyperf.php server:watch php bin/hyperf.php start 补充： 删除文件需要手动重启才能生效。 vendor 中的文件需要使用 classmap 形式自动加载才能被扫描。（即执行composer dump-autoload -o)","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"php","slug":"php","permalink":"http://swimtobird.github.io/tags/php/"},{"name":"hyperf","slug":"hyperf","permalink":"http://swimtobird.github.io/tags/hyperf/"},{"name":"swoole","slug":"swoole","permalink":"http://swimtobird.github.io/tags/swoole/"}]},{"title":"ab压测公司各框架对比","slug":"ab压测各框架对比","date":"2020-10-16T10:16:26.000Z","updated":"2020-11-17T03:30:02.864Z","comments":true,"path":"post/ab压测各框架对比.html","link":"","permalink":"http://swimtobird.github.io/post/ab压测各框架对比.html","excerpt":"","text":"以下压测的测试机配置如下 12345678910111213processor : 0vendor_id : GenuineIntelcpu family : 6model : 85model name : Intel(R) Xeon(R) Platinum 8269CY CPU @ 2.50GHzstepping : 7microcode : 1cpu MHz : 2500.000cache size : 36608 KBphysical id : 0siblings : 2core id : 0cpu cores : 1 hyperf1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556[root@iZwz9dkdcnxsz2ul6p6n7iZ ~]# ab -k -c 100 -n 10000 http://127.0.0.1:9501/This is ApacheBench, Version 2.3 &lt;$Revision: 655654 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/Licensed to The Apache Software Foundation, http://www.apache.org/Benchmarking 127.0.0.1 (be patient)Completed 1000 requestsCompleted 2000 requestsCompleted 3000 requestsCompleted 4000 requestsCompleted 5000 requestsCompleted 6000 requestsCompleted 7000 requestsCompleted 8000 requestsCompleted 9000 requestsCompleted 10000 requestsFinished 10000 requestsServer Software: HyperfServer Hostname: 127.0.0.1Server Port: 9501Document Path: /Document Length: 42 bytesConcurrency Level: 100Time taken for tests: 1.294 secondsComplete requests: 10000Failed requests: 0Write errors: 0Keep-Alive requests: 10000Total transferred: 1900190 bytesHTML transferred: 420042 bytesRequests per second: 7725.38 [#/sec] (mean)Time per request: 12.944 [ms] (mean)Time per request: 0.129 [ms] (mean, across all concurrent requests)Transfer rate: 1433.56 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 0 0 0.3 0 3Processing: 0 13 10.1 10 108Waiting: 0 13 10.1 10 108Total: 0 13 10.2 10 108Percentage of the requests served within a certain time (ms) 50% 10 66% 11 75% 13 80% 15 90% 21 95% 27 98% 55 99% 60 100% 108 (longest request) Thinkphp3.x魔改版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556[root@iZwz9dkdcnxsz2ul6p6n7iZ ~]# ab -k -c 100 -n 10000 http://testlive.tosame.cn/mapi/index.phpThis is ApacheBench, Version 2.3 &lt;$Revision: 655654 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/Licensed to The Apache Software Foundation, http://www.apache.org/Benchmarking testlive.tosame.cn (be patient)Completed 1000 requestsCompleted 2000 requestsCompleted 3000 requestsCompleted 4000 requestsCompleted 5000 requestsCompleted 6000 requestsCompleted 7000 requestsCompleted 8000 requestsCompleted 9000 requestsCompleted 10000 requestsFinished 10000 requestsServer Software: nginx/1.8.0Server Hostname: testlive.tosame.cnServer Port: 80Document Path: /mapi/index.phpDocument Length: 5669 bytesConcurrency Level: 100Time taken for tests: 192.518 secondsComplete requests: 10000Failed requests: 0Write errors: 0Keep-Alive requests: 0Total transferred: 58940000 bytesHTML transferred: 56690000 bytesRequests per second: 51.94 [#/sec] (mean)Time per request: 1925.179 [ms] (mean)Time per request: 19.252 [ms] (mean, across all concurrent requests)Transfer rate: 298.98 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 1 2 0.4 2 6Processing: 25 1912 131.3 1908 2320Waiting: 24 1912 131.3 1908 2320Total: 27 1915 131.3 1910 2322Percentage of the requests served within a certain time (ms) 50% 1910 66% 1932 75% 1948 80% 1958 90% 1991 95% 2029 98% 2179 99% 2231 100% 2322 (longest request) 框架 每秒处理请求数 平均响应时间（ms） 压测并发量 Hyperf 7725.38 12.944 100 Thinkphp3.x魔改版 51.94 1925.179 100","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"ab","slug":"ab","permalink":"http://swimtobird.github.io/tags/ab/"}]},{"title":"jenkins安装及坑记录","slug":"jenkins安装及坑记录","date":"2020-10-15T11:12:19.000Z","updated":"2020-11-17T03:32:05.910Z","comments":true,"path":"post/jenkins安装及坑记录.html","link":"","permalink":"http://swimtobird.github.io/post/jenkins安装及坑记录.html","excerpt":"","text":"1. 安装命令行123wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat/jenkins.reporpm --import https://pkg.jenkins.io/redhat/jenkins.io.keyyum install jenkins 2. 初始化jenkins启动命令 1service jenkins start 配置默认端口 1vi /etc/sysconfig/jenkinsci 修改JENKINS_PORT=”7005” 3. Jenkenis报错：该jenkins实例似乎已离线及ssl问题 保留此离线页面，重新开启一个浏览器tab标签页 下载上传插件 输入输入网址http://服务器ip:7005/pluginManager/advanced 上传该skip-certificate-check.hpi 插件 进入该页面最底下，找到【升级站点】，把其中的链接改成http，http://updates.jenkins.io/update-center.json ，确定保存 Jenkins在下载插件之前会检查网络链接，会去读取配置文件的网址/var/lib/jenkins/updates/default.json,国内访问谷歌，肯定无法访问，把谷歌地址改成百度 输入输入网址http://服务器ip:7005/restart 执行重启 4. jenkins没有参数化构建过程选项 Build With Parameters 输入框式的参数 Persistent Parameter 下拉框式的参数 Git Parameter git参数 安装上述三个插件, 然后重启jenkins 5. Jenkins执行脚本提示没有权限的解决办法 打开配置文件 1vi /etc/sysconfig/jenkinsci 修改$JENKINS_USER=”root” 修改Jenkins相关文件夹用户权限 123chown -R root:root /var/lib/jenkinschown -R root:root /var/cache/jenkinschown -R root:root /var/log/jenkins 重启jenkins 1service jenkins restart","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"http://swimtobird.github.io/tags/jenkins/"},{"name":"持续构建","slug":"持续构建","permalink":"http://swimtobird.github.io/tags/持续构建/"}]},{"title":"elk错误记录","slug":"elk错误记录","date":"2020-10-05T03:03:23.000Z","updated":"2020-11-17T03:27:51.523Z","comments":true,"path":"post/elk错误记录.html","link":"","permalink":"http://swimtobird.github.io/post/elk错误记录.html","excerpt":"","text":"elk错误记录1&#123;&quot;type&quot;:&quot;index_not_found_exception&quot;,&quot;reason&quot;:&quot;no such index and [action.auto_create_index] contains [-*] which forbids automatic creation of the index&quot;,&quot;index_uuid&quot;:&quot;_na_&quot;,&quot;index&quot;:&quot;filebeat-6.7.2-2019.09.17&quot;&#125; 在kibana管理界面中点击DevTools，然后通过命令手动创建一个index PUT /nginx-test nohup /usr/share/logstash/bin/logstash -f /etc/logstash/conf.d/nginx.conf &gt;/dev/null &amp;;","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"elk","slug":"elk","permalink":"http://swimtobird.github.io/tags/elk/"}]},{"title":"Vue 列表分页搜索方案","slug":"Vuex列表分页搜索","date":"2019-11-11T03:12:23.000Z","updated":"2020-11-17T03:32:12.792Z","comments":true,"path":"post/Vuex列表分页搜索.html","link":"","permalink":"http://swimtobird.github.io/post/Vuex列表分页搜索.html","excerpt":"","text":"一、Vuex配置a.引入Vuex.js文件 1&lt;script src=\"&#123;&#123;autoVer('js/vuex.js')&#125;&#125;\"&gt;&lt;/script&gt; b.在Vue组件中用import引入Vuex配置文件，配置搜索条件，列表数据，分页； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;script type=\"module\"&gt;import store from '&#123;!! autoVer('js/store.js') !!&#125;' let app = new Vue(&#123; store, el: '#main', data:&#123; //搜索条件 fromData: &#123; id: '', sku_name:'', brand:'', companyName:'', selectedCateId:0, cateType:0, cateLv0:0, cateLv1:0, cateLv2:0, cateLv3:0, //stateTime: '2018-01-03', //endTime: '2018-03-01' &#125;, created() &#123; this.getListData(this.supplyingModeProduct[this.selectSupplyingModeId]); setTimeout(() =&gt; &#123; this.pageListData(); &#125;, 100) &#125;, methods:&#123; search1() &#123; const data = []; //检测搜索类型 if (this.fromData.companyName) &#123; data.push(&#123; key: 'company_name', value: this.fromData.companyName, type: '=' &#125;) &#125; if (this.fromData.sku_name) &#123; data.push(&#123; key: 'sku_name', value: this.fromData.sku_name, type: '~' &#125;) &#125; if (this.fromData.brand) &#123; data.push(&#123; key: 'brand', value: this.fromData.brand, type: '=' &#125;) &#125; if (this.fromData.selectedCateId) &#123; data.push(&#123; key: 'full_id', value: String(this.fromData.selectedCateId), type: 'whereIn' &#125;) &#125; if (this.fromData.cateType) &#123; data.push(&#123; key: 'material_type', value:Number(this.fromData.cateType), type: '=' &#125;) &#125; // if (this.fromData.stateTime &amp;&amp; this.fromData.endTime) &#123; // data.push(&#123; // key: 'time', // value: &#123; // stateTime: this.fromData.stateTime, // endTime: this.fromData.endTime // &#125;, // type: '|' // &#125;) // &#125; this.$store.dispatch('search', data); //将筛选的条件传入Vuex中 &#125;, // 分页 pageListData() &#123; this.$store.dispatch('pageData'); //调用Vuex的方法 &#125;, // 点击页 changeCurPage(...sheet) &#123; this.$store.commit('changeCurPage', sheet); //调用Vuex的方法 &#125;, &#125; &#125; &#125;)&lt;/script&gt; c.新建store.js，创建一个store对象，接收Vue组件中的方法与数据; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193//定义属性数据let state = &#123; listData: [], //数据 searchDate: [],//基数组 //分页参数 pageList: &#123; listData: [],//渲染的数据 page: 1,//当前页码 pageSize: 50,//每页条数 total: 0,//总数 pageData: &#123; curPage: 1, pageSize: 10, total: 0, totalPage: 0, pageIndex: [], itemStart: 0, itemEnd: 0 &#125; &#125;,&#125;;// 定义action,表示动作,用来定义方法，不能修改数据;//commit提交变化，修改数据的唯一方式就是显示提交mutationslet actions = &#123; // 获取数据 getListData(&#123;commit, state&#125;,data) &#123; commit('getListData', data); &#125;, //搜索 search(&#123;commit, state&#125;, formData) &#123; commit('search', formData); &#125;, // 分页 pageData(&#123;commit, state&#125;) &#123; commit('listItems', state); &#125;,&#125;;// 定义mutations，处理数据的改变let mutations = &#123; // 获取列表数据 getListData(state, data) &#123; state.listData = state.searchDate = data; &#125;, // 筛选 search(state, fromData) &#123; state.searchDate = state.listData; let results = []; // for (let i in state.searchDate)&#123; results.push(state.searchDate[i]); &#125; fromData.forEach(one =&gt; &#123; state.searchDate = results.filter(item =&gt; &#123; // 精确 if (one.type == '=') &#123; if (item[one.key] !== one.value) &#123; return false; &#125; &#125; // 模糊 if (one.type == '~') &#123; const keys = one.value .toUpperCase() // 转大写 .replace(' ', '') // 删掉空格 .split(''); // 切割成 单个字 if (!keys.every(key =&gt; item[one.key].toUpperCase().includes(key))) &#123; return false; &#125; &#125; // 判断日期 if (one.type == '|') &#123; let stateTime = new Date(one.value.stateTime).valueOf(); let endTime = new Date(one.value.endTime).valueOf(); let listTime = new Date(item[one.key]).valueOf(); if ((endTime &gt;= listTime &amp;&amp; listTime &gt;= stateTime) == false) &#123; return false; &#125; &#125; // where_in(数组包含) if (one.type == 'whereIn') &#123; if( _.indexOf(item[one.key], one.value) == -1) &#123; return false; &#125; &#125; return true; &#125;); results = state.searchDate; &#125;); setTimeout(()=&gt;&#123; state.pageList.listData = state.searchDate; &#125;,100); this.commit('listItems', state); &#125;, // 分页 listItems(state) &#123;state.pageList.listData = &#123;&#125;; // let d = eval('(' + data + ')'); // console.log(d); // var d = JSON.parse(data); let listData = &#123;&#125;; let i = 1; let index = 1; _.forEach(state.searchDate,function(item,key)&#123; if(i == state.pageList.pageSize+1)&#123; i=1; index++; &#125; if(typeof listData[index] == 'undefined')&#123; listData[index]=&#123;&#125;; &#125; listData[index][key] = &#123;&#125;; listData[index][key] = item; i++;&#125;); let returnData = &#123;data:listData[state.pageList.pageData.curPage],total:_.size(state.searchDate)&#125;; state.pageList.listData = returnData.data; state.pageList.total = returnData.total; this.commit('setPageList', state); return this; &#125;, // 计算出页面值 setPageList(state) &#123; state.pageList.total = parseInt(state.pageList.total); //总数 let curPage = parseInt(state.pageList.page); //当前选中的页 state.pageList.pageSize = parseInt(state.pageList.pageSize); //每页的个数 let totalPage = Math.ceil(state.pageList.total / state.pageList.pageSize); //总数除以每页个数 let pageIndex = []; if (curPage &gt;= 1 &amp;&amp; curPage &lt;= totalPage) &#123; if (totalPage &lt; 5) &#123;//5页以内 for (let $i = 1; $i &lt;= totalPage; $i++) &#123; pageIndex.push($i); &#125; &#125; else &#123;//大于5页 if (curPage == 1) &#123; pageIndex = [curPage, curPage + 1, curPage + 2, curPage + 3, curPage + 4]; &#125; else if (curPage == 2) &#123; pageIndex = [curPage - 1, curPage, curPage + 1, curPage + 2, curPage + 3]; &#125; else if (curPage == totalPage - 1) &#123; pageIndex = [curPage - 3, curPage - 2, curPage - 1, curPage, totalPage]; &#125; else if (curPage == totalPage) &#123; pageIndex = [curPage - 4, curPage - 3, curPage - 2, curPage - 1, curPage]; &#125; else &#123; pageIndex = [curPage - 2, curPage - 1, curPage, curPage + 1, curPage + 2]; &#125; &#125; &#125; state.pageList.pageData.curPage = curPage; state.pageList.pageData.pageSize = state.pageList.pageSize; state.pageList.pageData.total = state.pageList.total; state.pageList.pageData.totalPage = totalPage; state.pageList.pageData.pageIndex = pageIndex; &#125;, //点击页 changeCurPage(state, sheet) &#123; state.pageList.page = sheet[1]; state.pageList.pageData.curPage = sheet[1]; state.pageList.pageSize = sheet[2]; this.commit('listItems', state) &#125;, &#125;;//创建一个store对象const store = new Vuex.Store(&#123; state, // getters, actions, mutations&#125;);// 导出store对象export default store;","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://swimtobird.github.io/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"http://swimtobird.github.io/tags/vuex/"}]},{"title":"武林科技技术架构演变","slug":"武林科技技术架构演变","date":"2019-07-22T11:12:19.000Z","updated":"2020-11-17T03:17:00.127Z","comments":true,"path":"post/武林科技技术架构演变.html","link":"","permalink":"http://swimtobird.github.io/post/武林科技技术架构演变.html","excerpt":"","text":"[TOC] 一、当前1.0版本1、技术架构 从物理层面可以看到，当前是将所有技术实现放在一起的，而架构层面是在简单实现(PHP+MySQL+HTML）。nginx是反向代理并且调度运行php的环境；php-fpm是执行php的运行环境；storage则是当前我们的存储地方，主要使用了数据库存储和本地缓存存在。 2、技术选型 名称 选型 版本 备注 后端开发语言 php 5.57.0↑ 当前已完成一次版本升级 后端开发框架 laravel 5.1 无 数据库 mysql 5.6 无 反向代理 nginx 1.8 无 缓存方式 本地缓存 无 无 二、未来2.0版本1、技术选型 名称 选型 版本 备注 后端开发语言 php 7.0 无 后端开发框架 laravel 5.15.5↑ 未来版本不会在原有5.1版本上，而是从5.5开始 数据库 mysql 5.6 无 反向代理 nginx 1.8 无 缓存方式 redis 2.8 无 2、架构设计2.1、架构愿景重点在于理解“中台”，我们意在创造一个真正的中台，这个中台承载武林多年来的经验，数据甚至解决方案的输出，输出到给开发者，合作方。 因此，我们需要定义这个“中台”，他是武林一个新的入口，也是未来一个很重要的入口，所以这里面所有的东西都是全新的都是规范的，都是标准的。 我们需要认真对待，严格设计与把关每一个接口，审核开发的质量。 我们的目标是打造一个武林的中台，承接武林的开发者，合作方以及未来一切的可能。 2.2、设计遵循原则 低耦合 服务化 RESTFul 2.3、架构执行流程图 ui层 ui层是用户看到并与之交互的界面，它只是作为一种输出数据并允许用户操纵的方式。 数据访问层 数据访问层拥有最多的处理任务，model与数据格式无关，这样一个模型能为多个ui提供数据，由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。 业务逻辑层 业务逻辑层提供业务逻辑接口，比如登陆、注册、绑定微信等接口 基础服务层 基础服务层集成与了数据层的交互，并有最基础的领域处理逻辑，且服务对象之间的交互不能在这层出现。 数据存储层 2.3.1、前端架构细化执行流程图技术选型：选择Vue1.足够的小巧，轻量，关注点聚焦，不会干扰整体项目设计架构；同时也有全家桶来做关注点分离，需要更多能力时全家桶中有可选择的项，减少重新造轮子。2.上手成本低、开发效率也很高3.Vue生态成熟和有庞大的开发者群体 架构定义 2.3.2、后端架构细化执行流程图 2、迎接更高标准2.1、自动化 监控 构建 测试 2.2、容灾2.3、后备切换方案三、达成2.0需求硬件资源1.服务器背景目前服务器并没有测试与正式之分，容易出现没有确认情况并没有出现正式，而一些尝新功能也只是冒险上线正式观看发布情况，急需提供测试环境来避免bug出现正式，特别是如果已经对接我们合作企业。 重要程度***** 需要数量2 预计需要成本536元/月 2、数据库mysql背景目前武林系统一切数据存储仅仅存放公司仅有一台服务器中，使用资源相当紧张，风险也是相当危险，如果正式推出外部，十分建议建议考虑单独使用数据库服务器 重要程度***** 需要数量1 预计需要成本620元/月 3、带宽与负载均衡背景目前我司服务器带宽是使用固定5M的，而从我们业务考虑，大部分使用场景是不需要那么高，当然我们要考虑突发状况，所以我建议未来是使用阿里云的slb(负载均衡)，预计会比我们原来方案每个月省下一百多元，而应对突发上升的流量，slb本身也可已支持10M以上带宽。 重要程度***** 需要数量1 预计需要成本14.88元/月0.8元/GB 4、缓存redis背景考虑到提高系统响应速度，除了要求开发者本身设计数据表和使用查询合理之外，技术上更快解决此类问题是使用缓存解决，而此使用比较成熟的缓存方案是使用redis,当前资源不太紧张时候可以在本服务器建立，不过考虑资源紧张，建议在适当时候购买该服务。 重要程度*** 需要数量1 预计需要成本420元/月","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://swimtobird.github.io/tags/架构/"}]},{"title":"CORS 规范","slug":"CORS规范","date":"2019-06-21T03:16:26.000Z","updated":"2020-11-17T03:32:11.176Z","comments":true,"path":"post/CORS规范.html","link":"","permalink":"http://swimtobird.github.io/post/CORS规范.html","excerpt":"","text":"为了更好管理和解决跨域请求, 结合 CORS 标准, 制订这份规范. Nginx Or PHP?PHP. 从几点来做考虑. 并非所有 API 都支持跨域调用如果使用 nginx, 一般需要通过正则来解决, 而在代码中, 通过指定路由组使用 CorsMiddleware 即可. ####[Access-Control-Request-Method一般情况下, 我们会一次性下发所有允许跨域调用的 methods. 而有时仅会返回访问的 path 所支持的 methods. 例如 GET /orders, 返回的 methods 可能仅有 GET, POST. Access-Control-Allow-Credentials当 Access-Control-Allow-Credentials 的值为 true 时, Access-Control-Allow-Origin 不允许设置为 *. 预检请求处理维护参数变更时, 修改 php 代码比修改 nginx 配置好. … 综合所有, 选择使用 PHP 来实现. laravel可以使用 barryvdh/laravel-cors 暂无 参考 https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS https://github.com/asm89/stack-cors","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"php","slug":"php","permalink":"http://swimtobird.github.io/tags/php/"},{"name":"cros","slug":"cros","permalink":"http://swimtobird.github.io/tags/cros/"}]},{"title":"显式路由与隐式路由","slug":"显式路由","date":"2019-06-21T03:16:26.000Z","updated":"2020-11-17T03:11:16.346Z","comments":true,"path":"post/显式路由.html","link":"","permalink":"http://swimtobird.github.io/post/显式路由.html","excerpt":"","text":"首先它们两者哪个好，有个前提条件，有没有约定与规范。 先说这样一个场景，搞seo的同事某一天找到开发人员，需要你提供一个新路由，实现功能是和老路由一样的，基于这样情况下，如果使用隐式路由的，就需要在新控制器单独复制一份；而使用显式路由，好处显而易见，直接创建新路由指向原来控制器方法即可。而这就是没有约定与规范前提，显示路由的好处之一。 显式路由主要是灵活，可以满足url定制、隐藏函数命名；并且对于开发人员也是有很大好处，一份好的显式路由，等于一份好文档的目录，方便人员快速知道当前对外暴露的url以及相关路由功能。 隐式路由则是没有这些方面的需求，比如后台系统，或者没有维护路由必要，那就可以用上。","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"php","slug":"php","permalink":"http://swimtobird.github.io/tags/php/"}]},{"title":"Vuex使用","slug":"Vuex使用方案","date":"2019-06-21T03:12:23.000Z","updated":"2020-11-17T03:07:34.958Z","comments":true,"path":"post/Vuex使用方案.html","link":"","permalink":"http://swimtobird.github.io/post/Vuex使用方案.html","excerpt":"","text":"一、Vuex简介​ uex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 ​ 二、Vuex的步骤1. 使用npm安装:npm install vuex --save 2. 使用script标签引入:123&lt;script src=\"/path/to/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"/path/to/vuex.js\"&gt;&lt;/script&gt; 3. 如果使用npm方式安装Vuex插件，在使用Vuex插件之前需要在main.js入口文件中3.1 使用import方式引入Vuex1import Vuex from ‘vuex’ 3.2 使用import方式引入Vuex1Vue.use(Vuex); 4. 安装之后可以通过Vuex实例对象的Store方法创建一个store对象：123456789101112131415161718192021222324252627282930/** * vuex配置 * **///定义属性数据let state = &#123;&#125;;// 定义action,表示动作,用来定义方法，不能修改数据;//commit提交变化，修改数据的唯一方式就是显示提交mutationslet actions = &#123;&#125;;// 定义mutations，处理数据的改变let mutations = &#123;&#125;;//创建一个store对象const store = new Vuex.Store(&#123; state, // getters, actions, mutations&#125;);// 导出store对象export default store; 5. 在Vue实例中注册store对象：123456import store from '文件路径'let app = new Vue(&#123; store, el:'#main', data:&#123;&#125;&#125;) 6. 在组件中使用state数据：必须通过computed属性使用state数据！否则state属性中的数据发生更改时不会反映在组件上！ 123456789101112131415161718import store from '文件路径'let app = new Vue(&#123; store, el:'#main', data&#123;&#125;, methods:&#123; search()&#123; this.$store.dispatch('search', data); //调用Vuex里面的actions方法; this.$store.commit('changeCurPage', data); //调用Vuex里面的mutations方法; &#125; &#125;, computed:&#123; list()&#123; return this.$store.state.pageList.listData; //获取Vuex中state的数据 &#125; &#125;&#125;) 7. 注意事项：7.1 基本组成：注意到这个store对象包含三个子对象： ​ state、mutations、actions 其中state用于存储数据，类似vue实例的data属性。 mutations用于递交更改，对state对象中的属性数据进行更改。 actions用于进行递交异步更改，通过调用mutations实现对数据的更改。 7.2 actions与mutations的区别​ 其中actions区别于mutations的地方在于mutations只能进行同步更改，而actions中的更改可以是异步执行。所以基本上所有用户执行的直接数据更改都是触发mutations属性 函数执行，而需要与后端进行数据交互的数据更改通常是通过actions属性函数去执行。 三、vuejs里面的变量，怎么用浏览器的console查看？解决方案1: 使用 vue-devtool详细教程：http://www.php.cn/js-tutorial-404390.html 解决方案2: 手动打印可以在mounted里加入 window.vue = this； 浏览器 控制台 vue._data；","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://swimtobird.github.io/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"http://swimtobird.github.io/tags/vuex/"}]},{"title":"elk(日志采集分析系统)安装部署","slug":"elk(日志采集分析系统)安装部署","date":"2018-11-23T03:03:23.000Z","updated":"2020-11-17T02:59:38.038Z","comments":true,"path":"post/elk(日志采集分析系统)安装部署.html","link":"","permalink":"http://swimtobird.github.io/post/elk(日志采集分析系统)安装部署.html","excerpt":"","text":"一、背景ELK设置有四个主要组件： Logstash：用于处理传入的日志Logstash的服务器组件 Elasticsearch：存储所有的日志 Kibana：网络接口，用于搜索和可视日志，这将在通过Nginx的代理 Filebeat： 安装的客户端服务器将发送其日志Logstash上，Filebeat作为一个利用樵夫网络协议与Logstash通信的日志传送代理（暂时由于公司业务不需要集群，不需要用到) 其他： ElastAlert:监控日志 二、前期准备ELK服务器需要硬件配置 操作系统：ubuntu 16.04 RAM：4GB CPU：2 三、安装1.java8 安装添加Java PPA为apt ： 1sudo add-apt-repository -y ppa:webupd8team/java 更新apt包数据库： 1sudo apt-get update 使用此命令安装最新稳定版本的Oracle Java 8： 1sudo apt-get -y install oracle-java8-installer 2.Elasticsearch 安装添加Elasticsearch公共GPG密钥导入apt： 1wget -qO - https://packages.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add - 创建Elasticsearch源列表： 1echo &quot;deb http://packages.elastic.co/elasticsearch/2.x/debian stable main&quot; | sudo tee -a /etc/apt/sources.list.d/elasticsearch-2.x.list 更新apt再次包数据库： 1sudo apt-get update 使用此命令安装Elasticsearch： 1sudo apt-get -y install elasticsearch Elasticsearch现已安装。 让我们编辑配置： 1sudo vim /etc/elasticsearch/elasticsearch.yml 您将要限制对Elasticsearch实例（端口9200）的外部访问，因此外部人员无法读取您的数据或通过HTTP API关闭Elasticsearch集群。 查找指定线路network.host ，取消它，并与“localhost”的，所以它看起来像这样替换它的价值： /etc/elasticsearch/elasticsearch.yml excerpt（updated） 1network.host: localhost 保存并退出elasticsearch.yml 。 现在，启动Elasticsearch： 1sudo systemctl restart elasticsearch 然后，运行以下命令在启动时启动Elasticsearch： 12sudo systemctl daemon-reloadsudo systemctl enable elasticsearch 3.Kibana 安装添加Kibana 公共GPG密钥导入apt： 1wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add - 将Kibana添加到源列表中： 1echo &quot;deb https://artifacts.elastic.co/packages/6.x/apt stable main&quot; | sudo tee -a /etc/apt/sources.list.d/elastic-6.x.list 更新apt包数据库： 1sudo apt-get update 使用此命令安装Kibana： 1sudo apt-get -y install kibana Kibana现已安装。 打开Kibana配置文件进行编辑： 1sudo vim /etc/kibana/kibana.yml 在Kibana配置文件，找到指定线server.host ，并替换为“本地主机”的IP地址（由“0.0.0.0”默认值）： /opt/kibana/config/kibana.yml excerpt（updated） 1server.host: &quot;localhost&quot; 保存并退出。 这个设置使得Kibana只能访问localhost。 这很好，因为我们将使用Nginx反向代理允许外部访问。 现在启用Kibana服务，并启动它： 123sudo systemctl daemon-reloadsudo systemctl enable kibanasudo systemctl start kibana 4.加载Kibana仪表板Elastic提供了几个样例Kibana仪表板和Beats索引模式，可以帮助您开始使用Kibana。 虽然我们不会在本教程中使用仪表板，我们仍将加载它们，以便我们可以使用它包括的Filebeat索引模式。 使用curl将文件下载到你的主目录： 12cd ~curl -L -O https://download.elastic.co/beats/dashboards/beats-dashboards-1.2.2.zip 安装unzip包用这个命令： 1sudo apt-get -y install unzip 接下来，提取归档的内容： 1unzip beats-dashboards-*.zip 并使用以下命令将样本仪表板，可视化和Beats索引模式加载到Elasticsearch中： 12cd beats-dashboards-*./load.sh 5.logstash 安装Logstash添加到我们的源列表： 1echo &quot;deb http://packages.elastic.co/logstash/2.3/debian stable main&quot; | sudo tee -a /etc/apt/sources.list 更新apt包数据库： 1sudo apt-get update 使用此命令安装Logstash： 1sudo apt-get install logstash 四、使用1.logstash命令行参数Logstash 提供了一个 shell 脚本叫 logstash 方便快速运行。它支持以下参数： -e 事实上你可以不写任何具体配置，直接运行 logstash -e &#39;&#39; 达到相同效果。这个参数的默认值是下面这样： 123456input &#123; stdin &#123; &#125;&#125;output &#123; stdout &#123; &#125;&#125; –config 或 -f 意即文件。真实运用中，我们会写很长的配置，甚至可能超过 shell 所能支持的 1024 个字符长度。所以我们必把配置固化到文件里，然后通过 bin/logstash -f agent.conf 这样的形式来运行。 此外，logstash 还提供一个方便我们规划和书写配置的小功能。你可以直接用 logstash -f /etc/logstash.d/ 来运行。logstash 会自动读取 /etc/logstash.d/ 目录下所有 *.conf 的文本文件，然后在自己内存里拼接成一个完整的大配置文件，再去执行。 注意： logstash 列出目录下所有文件时，是字母排序的。而 logstash 配置段的 filter 和 output 都是顺序执行，所以顺序非常重要。采用多文件管理的用户，推荐采用数字编号方式命名配置文件，同时在配置中，严谨采用 if 判断限定不同日志的动作。 –configtest 或 -t 即测试。用来测试 Logstash 读取到的配置文件语法是否能正常解析。Logstash 配置语法是用 grammar.treetop 定义的。尤其是使用了上一条提到的读取目录方式的读者，尤其要提前测试。 –log 或 -l 即日志。Logstash 默认输出日志到标准错误。生产环境下你可以通过 bin/logstash -l logs/logstash.log 命令来统一存储日志。 –pipeline-workers 或 -w 运行 filter 和 output 的 pipeline 线程数量。默认是 CPU 核数。 –pipeline-batch-size 或 -b 每个 Logstash pipeline 线程，在执行具体的 filter 和 output 函数之前，最多能累积的日志条数。默认是 125 条。越大性能越好，同样也会消耗越多的 JVM 内存。 –pipeline-batch-delay 或 -u 每个 Logstash pipeline 线程，在打包批量日志的时候，最多等待几毫秒。默认是 5 ms。 –pluginpath 或 -P 可以写自己的插件，然后用 bin/logstash --pluginpath /path/to/own/plugins 加载它们。 –verbose 输出一定的调试日志。 –debug 输出更多的调试日志。 2.logstash采集nginx配置nginx格式修改json123456789101112131415log_format json &apos;&#123;&quot;@timestamp&quot;:&quot;$time_iso8601&quot;,&apos; &apos;&quot;host&quot;:&quot;$server_addr&quot;,&apos; &apos;&quot;clientip&quot;:&quot;$remote_addr&quot;,&apos; &apos;&quot;size&quot;:$body_bytes_sent,&apos; &apos;&quot;responsetime&quot;:$request_time,&apos; &apos;&quot;upstreamtime&quot;:&quot;$upstream_response_time&quot;,&apos; &apos;&quot;upstreamhost&quot;:&quot;$upstream_addr&quot;,&apos; &apos;&quot;http_host&quot;:&quot;$host&quot;,&apos; &apos;&quot;url&quot;:&quot;$uri&quot;,&apos; &apos;&quot;request_uri&quot;:&quot;$request_uri&quot;,&apos; &apos;&quot;complete_url&quot;:&quot;$scheme://$host$request_uri&quot;,&apos; &apos;&quot;xff&quot;:&quot;$http_x_forwarded_for&quot;,&apos; &apos;&quot;referer&quot;:&quot;$http_referer&quot;,&apos; &apos;&quot;agent&quot;:&quot;$http_user_agent&quot;,&apos; &apos;&quot;status&quot;:&quot;$status&quot;&#125;&apos;; 然后添加logstash配置 1234567891011121314input &#123; file &#123; path =&gt; &quot;/path/access.log&quot; codec =&gt; json &#125;&#125;filter &#123; mutate &#123; split =&gt; [ &quot;upstreamtime&quot;, &quot;,&quot; ] &#125; mutate &#123; convert =&gt; [ &quot;upstreamtime&quot;, &quot;float&quot; ] &#125;&#125; 3.Elasticsearch运行遇到问题12345678910111213141516171819 ~  elasticsearch Exception in thread &quot;main&quot; ElasticsearchException[Failed to load logging configuration]; nested: NoSuchFileException[/usr/share/elasticsearch/config];Likely root cause: java.nio.file.NoSuchFileException: /usr/share/elasticsearch/config at sun.nio.fs.UnixException.translateToIOException(UnixException.java:86) at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:102) at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:107) at sun.nio.fs.UnixFileAttributeViews$Basic.readAttributes(UnixFileAttributeViews.java:55) at sun.nio.fs.UnixFileSystemProvider.readAttributes(UnixFileSystemProvider.java:144) at sun.nio.fs.LinuxFileSystemProvider.readAttributes(LinuxFileSystemProvider.java:99) at java.nio.file.Files.readAttributes(Files.java:1737) at java.nio.file.FileTreeWalker.getAttributes(FileTreeWalker.java:225) at java.nio.file.FileTreeWalker.visit(FileTreeWalker.java:276) at java.nio.file.FileTreeWalker.walk(FileTreeWalker.java:322) at java.nio.file.Files.walkFileTree(Files.java:2662) at org.elasticsearch.common.logging.log4j.LogConfigurator.resolveConfig(LogConfigurator.java:142) at org.elasticsearch.common.logging.log4j.LogConfigurator.configure(LogConfigurator.java:103) at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:243) at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:35)Refer to the log for complete error details. 通过运行命令解决: ln -s /etc/elasticsearch/ /usr/share/elasticsearch/config. 五、入门资源 https://www.ctolib.com/docs/sfile/ELKstack-guide-cn/logstash/index.html https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"elk","slug":"elk","permalink":"http://swimtobird.github.io/tags/elk/"}]},{"title":"js插件使用directive包裹","slug":"js插件使用directive包裹","date":"2018-11-12T11:12:19.000Z","updated":"2020-11-17T03:53:55.022Z","comments":true,"path":"post/js插件使用directive包裹.html","link":"","permalink":"http://swimtobird.github.io/post/js插件使用directive包裹.html","excerpt":"","text":"问题： 在vue中使用bootstrap datetimepicker时发现双向绑定不起作用了，bootstrap datetimepicker修改的日期不会同步到data中； 123456789101112131415161718data:&#123; submit_time_work:&#123; work_time:null &#125;,&#125;dataTime:function()&#123; $('#timing_data').datetimepicker(&#123; \"minView\": \"month\", \"autoclose\": true, \"format\": \"yyyy-mm-dd\", \"language\": \"zh-CN\", \"pickerPosition\": \"bottom-left\", \"todayHighlight\": true, &#125;).on('hide', function (ev) &#123; let value = $(\"#timing_data input\").val(); app.submit_time_work.work_time = value; &#125;);&#125; 总结： 其实也就是在datetimepicker的设置里面添加一个事件，当选择器hide时，将选择框的值赋值给vue里面的data的time。 选用方案一，原因是效率上相对快并根治问题。","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"http://swimtobird.github.io/tags/js/"}]},{"title":"关于css、js404问题解决方案","slug":"关于css、js404问题解决方案","date":"2018-11-12T11:12:19.000Z","updated":"2020-11-17T02:45:13.680Z","comments":true,"path":"post/关于css、js404问题解决方案.html","link":"","permalink":"http://swimtobird.github.io/post/关于css、js404问题解决方案.html","excerpt":"","text":"一、问题描述服务器日志出现相关css、js的map路由404情况 二、具体方案 A 将css.map文件移除; 将公用的JS文件添加Js.map文件; B 将Map指向CDN 三、方案比较 方案 优点 缺点 A js.map生成简单，解决map 404问题 要每个js文件生成js.map文件，工作量大 B map之前CDN，解决404问题 没有解决map问题 四、结论 选用方案一，原因是效率上相对快并根治问题。 五、当前执行情况 css.map文件移除(待跟进); 将公用的JS文件添加Js.map文件(待测试);","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"js","slug":"js","permalink":"http://swimtobird.github.io/tags/js/"},{"name":"css","slug":"css","permalink":"http://swimtobird.github.io/tags/css/"}]},{"title":"Swoole_tracker 如何跟踪与分析","slug":"Swoole_tracker_user","date":"2018-10-20T02:32:19.000Z","updated":"2020-11-17T03:32:06.680Z","comments":true,"path":"post/Swoole_tracker_user.html","link":"","permalink":"http://swimtobird.github.io/post/Swoole_tracker_user.html","excerpt":"","text":"进程列表统计客户端fpm和cli的pid，可进行远程调试、查看调用栈以及进程CPU和内存占用统计 远程调试对于以下四种工具，可以直接在服务端点击按钮远程开启后进行调试，无需修改代码，重启服务。开启后发生请求，日志自动上传服务端后台进行分析展示 对性能有所影响，开启调试完毕后请及时关闭。 阻塞检测可详细看到阻塞的堆栈信息，执行耗时，系统调用信息 内存泄漏 会获取到存在内存泄漏的文件堆栈信息，说明你需要在代码逻辑执行完毕后将该键名 unset 掉，就可以解决内存泄漏问题 性能分析性能分析可以生成分层分析表、调用图和火焰图，都可以直观的找到对应的瓶颈所在 分层分析表 调用图 火焰图","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"php","slug":"php","permalink":"http://swimtobird.github.io/tags/php/"}]},{"title":"php性能追踪及分析工具对比","slug":"php性能追踪及分析工具比较","date":"2018-10-19T03:32:19.000Z","updated":"2020-11-17T03:54:04.063Z","comments":true,"path":"post/php性能追踪及分析工具比较.html","link":"","permalink":"http://swimtobird.github.io/post/php性能追踪及分析工具比较.html","excerpt":"","text":"blackfire xhprof Molten 一、日常使用环境 blackfire:生产环境、开发环境 xhprof:生产环境、开发环境 Molten:生产环境、开发环境 二、限制 blackfire:需要用户配合blackfire插件，并不是所有群体都可捕捉记录 xhprof:任何群体使用皆可捕捉记录 Molten:同上 三、支持版本 blackfire:php5.4-7.2 xhprof:php5.4-7.2 Molten:php5.6-7.2 四、功能： blackfire:项目服务资源消耗情况统计、运行热路径（可支持隐藏路径）、检测故障代码 xhprof:项目服务资源消耗情况统计、运行热路径 Molten: 五、安装难度 blackfire:上手则可以用，不需要过多编译与安装 xhprof:需要重新编译安装php拓展，并结合Xhgui Molten:需要安装Zipkin,同样需要编译安装 六、上手难度 blackfire:上手则可以用 xhprof:仅有一对开关函数，以及几个参量，上手难度较低 Molten: 七、性能 blackfire:日常消耗不大 xhprof:通过配置频率，可以保证消耗资源不高 Molten:","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"php","slug":"php","permalink":"http://swimtobird.github.io/tags/php/"}]},{"title":"Swoole_Tracker安装使用说明","slug":"Swoole_Tracker安装使用说明","date":"2018-10-15T08:32:19.000Z","updated":"2020-11-17T03:32:08.132Z","comments":true,"path":"post/Swoole_Tracker安装使用说明.html","link":"","permalink":"http://swimtobird.github.io/post/Swoole_Tracker安装使用说明.html","excerpt":"","text":"一、Swoole_Tracker安装说明前提条件运行环境只能是linux,不支持unix、mac、Windows 1.登录后台https://business.swoole.com/获取tracker安装包地址 2.wget tracker的安装包地址 3.对下载脚本授权x，并执行 1chmod +x 安装包名称 &amp; ./安装包名称 4.查看php拓展路径并安装拓展 -ini | grep extension```12![img](/images/tracker3.png) cp 当前目录下swoole_tracker72.so php拓展路径/swoole_tracker.so1234![img](/images/tracker4.png)- 5.检查agent是否存在 ps aux | grep tracker-agent12345678910![img](/images/tracker5.png)- 完成安装，登录后台即可看到请求数据情况## 二、Swoole_Tracker客户端启动说明- 1./etc/init.d/node-agent restart- 2.检查agent是否存在 ps aux | grep tracker-agent`","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"php","slug":"php","permalink":"http://swimtobird.github.io/tags/php/"}]},{"title":"linux常用命令记录","slug":"linux","date":"2018-09-10T02:45:31.000Z","updated":"2020-11-17T02:58:12.222Z","comments":true,"path":"post/linux.html","link":"","permalink":"http://swimtobird.github.io/post/linux.html","excerpt":"","text":"前言收录了 linux 常用指令，这里面有个小技巧，基本上所有指令后面跟上 –h 可以显示其使用方法。故不必死记硬背，知其意乃通其形。 分类如下： 文件 &amp; 目录操作（16 个） 查看文件 &amp; 内容处理（18 个） 文件压缩 &amp; 解压缩（3 个） 信息显示（11 个） 搜索文件（4 个） 进程管理（11 个） 用户管理（7 个） 网络操作（11 个） 磁盘 &amp; 文件系统（7 个） 系统权限（3 个） 关机重启（5 个） 其他（6 个） 文件 &amp; 目录操作（16 个）ls ls -a 查看所有文件，包含隐藏文件 ls -l 简写 ll，查看详细信息 ls -h 文件大小以易读的方式显示 cd cd ../ 返回上级目录 cd ~ 前往家目录 cd - 返回上一次所在目录 cp cp -r 复制目录及目录下文件 find find / -name ‘target’ 查询根目录下面文件名为 target 的文件 mkdir mkdir -p /tmp/test 递归创建目录 mv mv -f source destination 强制 pwd pwd 显示当前路径 rm rm -rf / 强制删除根目录及目录下的文件，就是我们通常所说的删库跑路 touch touch target 创建 target 文件，若文件存在则改变文件时间戳 tree tree 功能是以树形结构显示目录下的内容 basename basename /tmp/1 显示文件名 dirname dirname /tmp/1 显示路径 chattr chattr +i /tmp/1 加 i 属性，防止文件被修改 lsattr lsattr /tmp/1 查看文件的扩展属性 file file /tmp/1 显示文件类型 md5 md5 /tmp/1 显示文件 MD5 值 查看文件 &amp; 内容处理（18 个）cat cat -n 显示行号 cat file1 file2 打开文件 1 和 2 more more file1 逐页显示 less less file1 也是逐页显示，与 more 方向相反 head head -n file 显示文件头 n 行 tail tail -n file 显示文件尾 n 行 tailf file 实时显示文件尾 10 行，常用于跟踪日志信息 cut who|cut -b 1-3,5 输出每行的 1 至 3 个字节和第 5 个字节 who|cut -c -3 输出每行的 1 至 3 个字符 who|cut -c 3- 输出每行的第 3 个字符到行尾 who|cut -d ‘ ‘ -f 1 以空格为分隔符，输出第一个域 split split -b 10k date.file 将文件分割为 10k 的多个子文件 split -b 10k date.file split_file 指定子文件前缀为 split_file paste psate file1 file2 file3 将 3 个文件按列合并 sort sort -n 按照数值大小排序 sort -r 倒序排序 sort -t 指定分隔符 sort -u 忽略相同行 uniq uniq -c 显示出现次数，只有相邻的才算重复 uniq -d 只显示重复的行 unqi -u 只显示不重复的行 wc wc -l 显示列数 diff diff file1 file2 比较两个文件差异 rev rev file 反向输出文件内容 grep grep ‘target’ file 过滤输出文件中包含 target 的行 grep -v ‘target’ file 过滤输出文件中不包含 target 的行 grep -c ‘target’ file 过滤输出文件中包含 target 的行数 grep -i ‘target’ file 忽略大小写 egrep ‘[1-9]|a’ file 过滤输出正则匹配到的行 seq 10 | grep “5” -A 3 显示匹配某个结果之后的 3 行 seq 10 | grep “5” -B 3 显示匹配某个结果之前的 3 行 seq 10 | grep “5” -C 3 显示匹配某个结果的前三行和后三行 join join file1 file2 将两个文件中，指定栏位内容相同的行连接起来 tr cat text | tr ‘\\t’ ‘ ‘ 将制表符替换成空格 vim三种模式： 编辑模式（命令模式） 输入模式 末行模式 模式的转换编辑 -&gt; 输入 1234567891011i: 在当前光标所在字符的前面，转为输入模式；a: 在当前光标所在字符的后面，转为输入模式；o: 在当前光标所在行的下方，新建一行，并转为输入模式；I：在当前光标所在行的行首，转换为输入模式A：在当前光标所在行的行尾，转换为输入模式O：在当前光标所在行的上方，新建一行，并转为输入模式； 输入 -&gt; 编辑 1ESC 编辑 -&gt; 末行： 1: 末行 -&gt; 编辑： 1ESC,ESC 打开文件12345vim +# :打开文件，并定位于第#行vim +：打开文件，定位至最后一行vim +/PATTERN : 打开文件，定位至第一次被PATTERN匹配到的行的行首 关闭文件123456789:q 退出:wq 保存并退出:q! 不保存并退出:w 保存:w! 强行保存 移动光标（编辑模式） 逐字符移动 123456789h: 左l: 右j: 下k: 上#h: 移动#个字符 以单词为单位移动 1234567w: 移至下一个单词的词首e: 跳至当前或下一个单词的词尾b: 跳至当前或前一个单词的词首#w: 移动#个单词 行内跳转 123450: 绝对行首^: 行首的第一个非空白字符$: 绝对行尾 行间跳转 12345#G：跳转至第#行gg: 第一行G：最后一行 翻屏1234567Ctrl+f: 向下翻一屏Ctrl+b: 向上翻一屏Ctrl+d: 向下翻半屏Ctrl+u: 向上翻半屏 删除单个字符123x: 删除光标所在处的单个字符#x: 删除光标所在处及向后的共#个字符 删除命令: d12dd: 删除当前光标所在行#dd: 删除包括当前光标所在行在内的#行； 撤消编辑操作1234567u：撤消前一次的编辑操作#u: 直接撤消最近#次编辑操作连续u命令可撤消此前的n次编辑操作撤消最近一次撤消操作：Ctrl+r 查找1234567/PATTERN?PATTERNn 下一个N 上一个 文件压缩 &amp; 解压缩（3 个）tar tar zxvf FileName.tar.gz 解压 tar zcvf FileName.tar.gz DirName 压缩 zip zip -r html.zip/home/html 递归压缩 unzipunzip test.zip -d /tmp 解压到指定目录下 信息显示（11 个）uname uname -a 显示系统全部信息 hostname hostname 显示主机名 dmesg dmesg 显示开机信息 uptime uptime 显示系统运行时间及负载 stat stat 显示文件的状态信息 du du -sh 显示路径下所有文件大小 du -sh local 显示路径下 local 目录文件大小 du -sh * 显示路径下所有目录文件大小 df df -h 显示系统磁盘空间的使用情况 top top 实时显示系统资源使用情况 free free -m 以 M 为单位查看系统内存 date date +”%Y-%m-%d” 2019-05-28 date -d “1 day ago” +”% Y-% m-% d” 输出昨天日期 date -d “+1 day” +% Y% m% d 显示前一天的日期 date -d “-1 day” +% Y% m% d 显示后一天的日期 date -d “-1 month” +% Y% m% d 显示上一月的日期 date -d “+1 month” +% Y% m% d 显示下一月的日期 date -d “-1 year” +% Y% m% d 显示前一年的日期 date -d “+1 year” +% Y% m% d 显示下一年的日期 cal cal 日历信息 搜索文件（4 个）which which pwd 显示命令路径 find find /-name ‘target’ 查询根目录下面文件名为 target 的文件 whereis whereis php 查找二进制命令 locate locate target 从数据库 (/var/lib/mlocate/mlocate.db) 查找目标文件，使用 updatedb 更新库 进程管理（11 个）jobs jobs 查看当前有多少在后台运行的命令 bg bg 1 将一个在后台暂停的命令，继续执行，1 为作业号（ctrl+z）可以挂起程序，返回作业号 fg fg 1 将后台中的命令调至前台继续运行 ，1 为作业号 kill kill 进程号 杀进程 kill -9 进程号 强杀进程 killall killall php 通过进程名字杀进程 killall -9 php 通过进程名字强杀进程 pkill 用法同上 crontab crontab -l 查看定时任务 crontab -e 编辑定时任务 crontab -l -u user1 查看 user1 定时任务，只有 root 才有权限 crontab -e -u user1 编辑 user1 定时任务，只有 root 才有权限 ps ps -ef 查看进程，显示 UID,PPIP,C 与 STIME，每个程序所使用的环境变量栏位 ps -axu 查看所有进程，并显示属于用户 pstree pstree -p 显示当前所有进程的进程号和进程 id 树 pstree -a 显示所有进程的所有详细信息树 nohup nohup command &amp; 退出账户时不挂断程序，仍在后台运行 pgrep pgrep -l httpd 查找 http 相关的进程号 用户管理（7 个）useradd useradd boy -u 888 建立一个新用户账户，并设置 ID useradd –g sales jack –G company,employees-g：加入主要组 -G：加入次要组 usermod usermod -G staff newuser2 将 newuser2 添加到组 staff 中 usermod -l newuser1 newuser 修改 newuser 的用户名为 newuser1 usermod -L newuser1 锁定账号 newuser1 usermod -U newuser1 解除对 newuser1 的锁定 userdel userdel -f user1 强制删除用户 userdel -r user1 删除用户的同时，删除与用户相关的所有文件 groupadd groupadd -g 1000 group1 建立一个新组，并设置组 ID 加入系统 passwd passwd user1 修改 user1 密码 passwd -l user1 锁住密码 passwd -d user1 删除密码 su su root 切换身份 sudo sudo command 已管理员身份运行命令 网络操作（11 个）telnet telnet 127.0.0.1 登录远程主机 ssh ssh root@127.0.0.1 -p22 登录远程主机 scp scp local_file remote_username@remote_ip:remote_folder 本地拷贝到远程 scp remote_username@remote_ip:remote_folder local_file 远程拷贝到本地 wget wget url 下载一个文件 wget –limit-rate=300k url 限速下载 wget -c url 断点续传 wget -b url 后台下载 ping ping www.baidu.com -c 2 收到两个包就结束 route route 显示当前路由 ifconfig ifconfig 查看、配置、启用或禁用网络接口 ifup ifup eth0 开启 eth0 网卡 ifdown ifdown eth0 关闭 eth0 网卡 netstat netstat -at 列出所有 tcp 端口 netstat -au 列出所有 udp 端口 netstat -l 只显示监听端口 ss ss -t -a 显示所有 tcp 链接 ss -l 显示处于监听状态的套接字 磁盘 &amp; 文件系统（7 个）mount mount /dev/hda1 /mnt 将 /dev/hda1 挂载到 /mnt 目录下 umount umount -v /mnt/mymount/ 卸载 /mnt/mymount/ fsck fsck -y /dev/hda2 检查并修复 Linux 文件系统 dumpe2fs dumpe2fs /dev/hda1 查看文件系统信息 dump ‍dump -0u -f /tmp/homeback.bak /home将 /home 目录所有内容备份到 /tmp/homeback.bak 文件中，备份层级为 0 并在 /etc/dumpdates 中记录相关信息 fdisk fdisk /dev/sdb输入 m 列出可以执行的命令输入 p 列出磁盘目前的分区情况输入 d 然后选择分区，删除现有分区输入 print 查看分区情况，确认分区已经删除输入 n 建立新的磁盘分区输入 w 最后对分区操作进行保存 mkfs mkfs -t ext3 /dev/sda6 将 sda6 分区格式化为 ext3 格式 系统权限（3 个）chmod chmod 777 file1 修改 file1 文件权限为 777 chmod u+x,g+w file1 为 file1 设置自己可以执行，组员可以写入的权限 chown chown -R root /usr/meng 修改将目录 /usr/meng 及其下面的所有文件、子目录的文件主改成 root chgrp chgrp -R mengxin /usr/meng 将 /usr/meng 及其子目录下的所有文件的用户组改为 mengxin 关机重启（5 个）shutdown shutdown -h now 立即关机 shutdown +5 “System will shutdown after 5 minutes” 指定 5 分钟后关机，同时送出警告信息给登入用户 halt halt -p 关闭系统后关闭电源 halt -d 关闭系统，但不留下纪录 poweroff poweroff -f 强制关闭操作系统 logout logout 退出当前登录的 Shell exit exit 退出当前登录的 Shell 其他（6 个）echo echo ‘hello’ 打印字符串、变量 print printf ‘hell0’ 格式化输出字符串 rpm rpm -ivh your-package.rpm 安装 rpm 包 rpm -Uvh your-package.rpm 升级 rpm 包 rpm -e package 卸载 rpm -qa 列出所有安装过的包 rpm -ql 包名 rpm 包中的文件安装到那里去 yum yum install php 安装 php yum remove php 卸载 php clear clear 清屏 history history 10 最近使用的 10 条历史命令","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://swimtobird.github.io/tags/linux/"}]},{"title":"算法压测方案","slug":"ab","date":"2018-03-31T03:16:26.000Z","updated":"2020-11-17T02:32:54.630Z","comments":true,"path":"post/ab.html","link":"","permalink":"http://swimtobird.github.io/post/ab.html","excerpt":"","text":"前期了解算法情况 相关算法是添加180秒缓存，因此使压测数据有实际意义需要两种方式去执行，一种是简单去掉算法的缓存，二是压测的请求参数都是唯一不重复值去请求 部分算法是涉及java调用 现有轮子是否满足需求现有主流压测工具 jmeter 1.支持http请求 2.本身并不提供图形化的实时数据展示功能 3.用户操作并不友好，配置相对复杂 ab 1.简单粗暴 2.不支持动态参数请求 LoadRunner 老牌压测工具 目标压测工具需要提供以下功能： 简单易用的操作界面（接入压测的时间应该控制在1小时以内） 清晰的图表能反映压测应用的各项指标 支持HTTP压测需求 总结1.整体上说jmeter满足需求 与目前想看，需求上还是满足当前需求的。 2.实时数据展示 JMeter本身并不提供图形化的实时数据展示功能，以往我们只能通过JMeter Log看到一些粗略的信息，并结合外部监控工具观察指标情况。可以通过JMeter的Backend Listener (JMeter 3.2+)，将测试结果实时发往InfluxDB，同时通过web_ui向InfluxDB轮询查询数据，得到实时曲线并展示给用户。 开始落地制造真实请求数据编写生产环境数据生产导出 监控线上情况目前只能通过简单观察服务器资源情况以及报警状态判断稳定性 压测爬坡数据量压测预设目标，不是一次达到，而有目的分开几个阶段，如每次增加100，每次持续5分钟等去慢慢爬坡压测。 到达第一个瓶颈的分析与优化初步压测得到的瓶颈不是压测的终点，而只是开始，这时候需要结合分析： 1.算法服务能力达到瓶颈了，拖累QPS不上去 2.网关本身能力达到瓶颈 3.中间件/数据库/Redis 能力达到瓶颈 针对第二三点出现问题核心是资源不够，添加服务器是相对比较快的速度去解决瓶颈办法；而针对出现的第一种情况，结合数据分析，如果是与预想相比实在低下，首先要做的检查业务逻辑，并切实拿出优化或者重构方案，不然还是需要添加服务器去支持。 未来展望当前，这个方案做得还较粗糙，还存在一些问题： 1 压测只能在夜间做。 2 链路规划复杂度太高。 3 压测稳定性还不够高。 4 瓶颈检测与流量干预是通过肉眼来观看监控来实现。 后续可以继续投入大精力去完善整个方案。希望可以做到，压测的方案可以变成： 1 压测任何时候都可以进行。 2 链路规划图形化，并与数据结合， 完成数据的准备工作。 3 瓶颈检测与流量干预来保护系统，让业务系统不会被压崩溃。","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"ab","slug":"ab","permalink":"http://swimtobird.github.io/tags/ab/"}]},{"title":"SQLAdvisor总结","slug":"sql","date":"2018-03-31T03:12:23.000Z","updated":"2020-11-17T02:32:54.631Z","comments":true,"path":"post/sql.html","link":"","permalink":"http://swimtobird.github.io/post/sql.html","excerpt":"","text":"背景1.开发人员大体完成数据表与CURD操作就没有下文了，等后续出现查询效率问题才迟迟开始优化 2.开发人员对索引的不合理使用，或者不会合理设计索引，导致索引本身在查询上没有发挥作用 总结目前看到可以基本简单解决以上场景问题的SQL的优化手段中,效果最显著的就是索引优化，而SQLAdvisor就是通过对你的SQL语句和索引项进行把脉,从而对你提出合理化的建议 快速开始1.docker部署docker pull imred/sqladvisor 2.执行命令docker run --rm imred/sqladvisor -h xx -P xx -u xx -p &#39;xx&#39; -d xx -q &quot;sql&quot; -v 1 使用体验 整体满足大部分查询索引优化要求，并快速得到优化建议 需要手动提供语句执行查询，体验上相对不友好，期盼是通过读取mysql日志自动执行并提供优化结果 对sql查询优化核心在索引上，更进一步觉得可以结合对提供语句提供优化建议 优化方案 自动化获取mysql日志并提供索引优化建议 初步想法： 1.开启mysql输出查询日志 2.agent(logstash)去采集过滤采集，将sql语句上报 3.编写接收sql语句,并过滤重复语句，首次出现语句调用SQLAdvisor执行，并输出结果 输出sql语句优化建议 初步想法： 暂时是先收集日常比较通用优化规则，基于整理后规则编写优化","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"sqladvisor","slug":"sqladvisor","permalink":"http://swimtobird.github.io/tags/sqladvisor/"},{"name":"sql优化","slug":"sql优化","permalink":"http://swimtobird.github.io/tags/sql优化/"}]},{"title":"接口设计","slug":"接口设计","date":"2017-08-13T05:23:12.000Z","updated":"2020-11-17T02:32:54.632Z","comments":true,"path":"post/接口设计.html","link":"","permalink":"http://swimtobird.github.io/post/接口设计.html","excerpt":"","text":"1.API 地址和版本在 url 中指定 API 的版本是个很好地做法。如果 API 变化比较大，可以把 API 设计为子域名，比如 https://api.github.com/v3；也可以简单地把版本放在路径中，比如 https://example.com/api/v1。 2.设计URL需要以资源为中心资源是 Restful API 的核心元素，所有的操作都是针对特定资源进行的。而资源就是 URL表示的，所以简洁、清晰、结构化的 URL 设计是至关重要的。Github 可以说是这方面的典范，下面我们就拿 repository 来说明。 12345/users/:username/repos/users/:org/repos/repos/:owner/:repo/repos/:owner/:repo/tags/repos/:owner/:repo/branches/:branch 我们可以看到几个特性： 资源分为单个文档和集合，尽量使用复数来表示资源，单个资源通过添加 id 或者 name 等来表示 一个资源可以有多个不同的 URL 资源可以嵌套，通过类似目录路径的方式来表示，以体现它们之间的关系 NOTE: URL是大小写敏感的。所以为了避免歧义，尽量使用小写字母。 3.正确使用Method有了资源的 URL 设计，所有针对资源的操作都是使用 HTTP 方法指定的。比较常用的方法有： Verb 描述 HEAD 只获取某个资源的头部信息。比如只想了解某个文件的大小，某个资源的修改日期等 GET 获取资源 POST 创建资源 PATCH 更新资源的部分属性。可惜PATCH 比较新，而且规范比较复杂，因此真正实现的比较少，所以可以用 POST 替代 PUT 替换资源，客户端需要提供新建资源的所有属性。如果新内容为空，要设置 Content-Length为 0，以区别错误信息 DELETE 删除资源 比如： 12345GET /repos/:owner/:repo/issuesGET /repos/:owner/:repo/issues/:numberPOST /repos/:owner/:repo/issuesPATCH /repos/:owner/:repo/issues/:numberDELETE /repos/:owner/:repo NOTE：更新和创建操作应该返回最新的资源，来通知用户资源的情况；删除资源一般不会返回内容。 不符合 CRUD 的情况在实际资源操作中，总会有一些不符合 CRUD 的情况，一般有几种处理方法。 使用 POST为需要的动作增加一个 endpoint，使用 POST 来执行动作，比如 POST /resend 重新发送邮件。 增加控制参数添加动作相关的参数，通过修改参数来控制动作。比如一个博客网站，会有把写好的文章“发布”的功能，可以用上面的 POST /articles/{:id}/publish 方法，也可以在文章中增加 published:boolean 字段，发布的时候就是更新该字段 PUT /articles/{:id}?published=true 把动作转换成资源把动作转换成可以执行 CRUD 操作的资源， github 就是用了这种方法。 比如“喜欢”一个 gist，就增加一个 /gists/:id/star 子资源，然后对其进行操作：“喜欢”使用 PUT /gists/:id/star，“取消喜欢”使用 DELETE /gists/:id/star。 另外一个例子是 Fork，这也是一个动作，但是在 gist 下面增加 forks资源，就能把动作变成 CRUD 兼容的：POST /gists/:id/forks 可以执行用户 fork 的动作。 4.查询更灵活比如查询某个 repo 下面 issues 的时候，可以通过以下参数来控制返回哪些结果： state：issue 的状态，可以是 open，closed，all since：在指定时间点之后更新过的才会返回 sort：选择排序的值，可以是 created_at、updated_at direction：排序的方向，升序（asc）还是降序（desc） …… ​ 5.返回适合状态码HTTP 应答中，需要带一个很重要的字段：status code。它说明了请求的大致情况，是否正常完成、需要进一步处理、出现了什么错误，对于客户端非常重要。状态码都是三位的整数，大概分成了几个区间： 状态码 解释 2XX 请求正常处理并返回 3XX 重定向，请求的资源位置发生变化 4XX 客户端发送的请求有错误 5XX 服务器端错误 接口文档谨记文档不是写自己看的，无论是做开发平台还是内部使用，请尽量描述详细（标准估计是你写完文档，别人可以不找到你本人，都可以找文档解决），不然无论以上设计多么优雅，也是白干活，切记切记！","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"api","slug":"api","permalink":"http://swimtobird.github.io/tags/api/"},{"name":"Restful","slug":"Restful","permalink":"http://swimtobird.github.io/tags/Restful/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-08-13T05:13:22.000Z","updated":"2020-11-17T02:54:18.409Z","comments":true,"path":"post/hello-world.html","link":"","permalink":"http://swimtobird.github.io/post/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"借用docker轻量快速配置php全家桶","slug":"借用docker轻量快速配置php全家桶","date":"2017-08-05T08:41:03.000Z","updated":"2020-11-17T02:32:54.631Z","comments":true,"path":"post/借用docker轻量快速配置php全家桶.html","link":"","permalink":"http://swimtobird.github.io/post/借用docker轻量快速配置php全家桶.html","excerpt":"","text":"闲聊扯淡话小弟我是p（pai）h（huang）p（pian）程序猿,期间在windows下开发一直感觉相当痛苦，特别是没有一套顺手的php开发环境，这样很难让我飙车到120。其实入门时候使用过wamp 、phpstudy 这些一键集成的软件，可是如果你只在windows下跑过你的代码，你会发现部署在linux的测试和生产环境，总会出现你在windows下不会出现的奇葩问题(当年血与泪的教训)。基于此，我慢慢转向了虚拟机，奔向了linux环境。 刚刚开始是直接使用centos环境配置，期间学习了不少东西，不过也因为我专业是嵌入式开发的，所以linux下使用的困难其实并没有可怕，缺点就是所有一切东西都需要直接去安装配置，十分繁琐，让新手可能很容易就沮丧和放弃。 直到后来，我发现homestead 这个好东西，再次感谢开源这个伟大发明。homestead也是一个虚拟机，基于ubuntu集成好了php基本一切环境，php、mysql、redis、memcached、hhvm、Beanstalkd、php-fpm、php-cli、nginx等等。安装前提，其实主要解决翻墙问题，其他看文档，基本都十分流程可以安装好，一次搞定，终身幸福，十分十分友好。 虽然homestead真的是很棒的东西，直到现在我依然在使用中，但是它也有它的不足。首先，启动十分十分的慢，我电脑是固态，也要花点等待启动，其次是升级比较麻烦。所以基于以上，我一直在寻找如果是纯粹简单快速开发环境，直到看到了docker，眼前一亮。 介绍DockerDocker 是一个开源项目,自动化部署应用程序软件的容器,在Linux, Mac OS and Windows提供一个额外的抽象层和自动化的操作系统级的虚拟化。这部分内容大家去度娘、谷歌，这里复制官方简介。 开始安装1 - 一键式安装docker for windows傻瓜式点击next就安装好，不补充说明了。 2 - 构建安装好了docker后，接下来就是我们利用开源的laraDock 构建开发环境了。 A）先克隆laraDock仓库代码 1git clone https://github.com/LaraDock/laradock.git B)进入laradock目录和复制和重命名.env-example为.env 1cp .env-example .env C)启动容器,如果使用的vpn好的话，估计等待时间不长，就下载构建完成，以后都是直接启动 1docker-compose up -d nginx mysql redis D)打开浏览器输入http://localhost 1That&apos;s it! enjoy :) 配置和操作1 - 配置说明A)目录说明 项目代码需要和laradock平级，也就是如下所示 123+ laradock+ project-1+ project-2 2 - 操作说明A）停用所有容器 1docker-compose stop 停用指定容器 1docker-compose stop &#123;container-name&#125; B)展示所有运行中容器 1docker-compose ps C)删除所有构建容器 1docker-compose down D)重建所有容器 1docker-compose build 重建指定容器 1docker-compose build &#123;container-name&#125; E)在容器运行命令 1docker-compose exec &#123;container-name&#125; bash 3 - 编辑默认容器配置打开docker-compose.yml并更改任何你想要的东西 例如 要更改mysql数据库默认配置账号为user，密码为123456 123### MYSQL ####MYSQL_USER=userMYSQL_PASSWORD=123456 修改完后记得执行重建容器命令 1docker-composer build mysql 4 - 疑惑A)通过ssh访问workspace 刚刚从linux虚拟机转换过来，总是习惯想通过ssh去访问workspace，其实并需要这样，因此其实你通过这个docker-compose exec workspace bash 去执行，转变过程我也花了点时间。如果有兴趣也可以看看这篇文章If you run SSHD in your Docker containers, you’re doing it wrong!，很明白说清楚为什么没有必要ssh去操作docker容器。 对了，友情提醒，如果你真不习惯这种方式，还是想要ssh去访问的话，要做两个事。先在.env配置里将INSTALL_WORKSPACE_SSH修改为true,然后执行docker-compose exec workspace bash，在执行之后和linux一样执行命令重置密码 感谢开这个博客，写了第一篇技术文章，感谢我女朋友bobo的大力支持。对的，我虽然是程序猿，可我是有女朋友的，不是左右手哟。 参考资料https://docs.docker.com/ http://laradock.io/ https://jpetazzo.github.io/2014/06/23/docker-ssh-considered-evil/","categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"php","slug":"php","permalink":"http://swimtobird.github.io/tags/php/"},{"name":"docker","slug":"docker","permalink":"http://swimtobird.github.io/tags/docker/"}]}],"categories":[{"name":"技术","slug":"技术","permalink":"http://swimtobird.github.io/categories/技术/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"http://swimtobird.github.io/tags/jenkins/"},{"name":"持续构建","slug":"持续构建","permalink":"http://swimtobird.github.io/tags/持续构建/"},{"name":"yapi","slug":"yapi","permalink":"http://swimtobird.github.io/tags/yapi/"},{"name":"centos6.9","slug":"centos6-9","permalink":"http://swimtobird.github.io/tags/centos6-9/"},{"name":"php","slug":"php","permalink":"http://swimtobird.github.io/tags/php/"},{"name":"hyperf","slug":"hyperf","permalink":"http://swimtobird.github.io/tags/hyperf/"},{"name":"swoole","slug":"swoole","permalink":"http://swimtobird.github.io/tags/swoole/"},{"name":"ab","slug":"ab","permalink":"http://swimtobird.github.io/tags/ab/"},{"name":"elk","slug":"elk","permalink":"http://swimtobird.github.io/tags/elk/"},{"name":"vue","slug":"vue","permalink":"http://swimtobird.github.io/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"http://swimtobird.github.io/tags/vuex/"},{"name":"架构","slug":"架构","permalink":"http://swimtobird.github.io/tags/架构/"},{"name":"cros","slug":"cros","permalink":"http://swimtobird.github.io/tags/cros/"},{"name":"js","slug":"js","permalink":"http://swimtobird.github.io/tags/js/"},{"name":"css","slug":"css","permalink":"http://swimtobird.github.io/tags/css/"},{"name":"linux","slug":"linux","permalink":"http://swimtobird.github.io/tags/linux/"},{"name":"sqladvisor","slug":"sqladvisor","permalink":"http://swimtobird.github.io/tags/sqladvisor/"},{"name":"sql优化","slug":"sql优化","permalink":"http://swimtobird.github.io/tags/sql优化/"},{"name":"api","slug":"api","permalink":"http://swimtobird.github.io/tags/api/"},{"name":"Restful","slug":"Restful","permalink":"http://swimtobird.github.io/tags/Restful/"},{"name":"docker","slug":"docker","permalink":"http://swimtobird.github.io/tags/docker/"}]}